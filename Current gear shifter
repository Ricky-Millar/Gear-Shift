
#include <EEPROM.h>
#include <Arduino.h>
#include <PulseClearpath.h>
#include <StepController.h>
#include <StepClearpath.h>
int incomingByte;
unsigned long time;
unsigned long ShiftTime;
unsigned long OldTime;
int n;
unsigned char i;
int upstate = 0;
int downstate = 0;
const int down = 2;
const int up = 3;
const int ledPin = 13;      // the number of the LED pin
int count = 0;
int count2 = 0;
int bananas = 0;
int G0 = 188;
int G1 =  0;
int G2 = 375;
int G3 = 750;
int G4 = 1125;
int G5 = 1500;
int G6 = 1875;
int neutral;
int Nshiftdirection;
int shiftdirection; // This int saves the previous move, used in recovering from a failed shift, 0 = Failedshift  1 = fullshift up    2 = fullshift down    3 = halfshift up    4 = halfshift down
  StepClearpath X; // initialize a StepClearpath Motor
  StepController machine(&X); //initialize the controller and pass the reference to the motor
int gear =  EEPROM.read(1);
int stepsperrev = 3200;
  double FullShift=stepsperrev/6; // distance in Steps - check step/rev in ClearPath MSP config file (1,600 steps/rev)
  double HalfShift=FullShift/2;


void setup() {

    pinMode(2,OUTPUT);  //DEBUG declare pin 2 as output.  Abe, this shows when the arduino is in the ISR
    Serial.begin(9600);
    X.attach(8,9,6,4);     //Direction/A is pin 8, Step/B is pin 9, Enable is pin 6, HLFB is pin 4  //JWS: HFLB = high level feedback info coming from motor to arduino
    X.setMaxVel(95000);  // Set max Velocity.  Parameter can be between 2 and 100,000
    X.setMaxAccel(2000000);  // Set max Acceleration.  Parameter can be between 4000 and 2,000,000
    X.enable();  // Enable motor, reset the motor position to 0 //JWS: enable happens automatically per Clearpath (whenever enabled) - no actual arduino code required

    Serial.print("Homing...");      // wait until the command is finished and then 1 more second
    while(X.readHLFB()) { 
        Serial.print('.');
      }
    
    Serial.println();
    Serial.println("Homing Complete");
    delay(200);
  
    machine.Start(249);     // Set up the ISR to constantly check motor position.  PARAMETER MUST BE SET TO 249

  if (gear>6)gear=0;
  //pinMode(8, OUTPUT);
 //digitalWrite(8, HIGH);
 // pinMode(9, INPUT_PULLUP);//the positive currect neutral grounds
  pinMode(down, INPUT_PULLUP);
  pinMode(up, INPUT_PULLUP);
  pinMode(11, INPUT_PULLUP);//NEUTRAL INDICATOR
  pinMode(12, INPUT_PULLUP);//GO TO NEUTRAL 
  pinMode(13, INPUT_PULLUP);//EMERGENCY MODE
  delay(3000);

//Wait for motor to finish initiation routine - If you give commands to motor on power on it may behave irratically
}
 
void ShiftCheck(){//checking if a full shift is completed
 delay(10);
  while(X.readHLFB()){ 
   count++;Serial.println(count);
   Serial.print('.');
    if(count >= 50){
        gear = EEPROM.read(1); 
        Serial.println();Serial.println("Falied Shift - attempting to revert");
        if(shiftdirection == 1){X.move(-FullShift);}//return to previous gear state if a gear change didnt happen in 3 seconds by doing the inverse of the last move
        if(shiftdirection == 2){X.move(FullShift);}
        if(shiftdirection == 3){X.move(-HalfShift);}
        if(shiftdirection == 4){X.move(HalfShift);}
        shiftdirection = 0;
        count = 0;return;
        }  
    }Serial.println();
  Serial.print("Succsessful shift, taking - ");Serial.print(millis()-OldTime);Serial.println("ms ish");delay(200); count = 0; 
  return;
}


bool NShiftCheck(){//checking if a full shift is completed
 delay(10);
  while(X.readHLFB()){ 
   count2++;Serial.println(count2);
   Serial.print('.');
    if(count2 >= 150){count2=0;
       return false;
        }  
    }Serial.println();
  Serial.print("Succsessful Neutral");delay(200); count2 = 0; return true;
}

void loop() {//Serial.print(X.readHLFB());
//Check for paddle presses
  upstate = digitalRead(up);
  downstate = digitalRead(down);


 
//Check If neutral button has been pressed for a time
/*
    if (digitalRead(9)==1)
    {n++; if (n > 5000) {n = 0; neutral = 1;Serial.println("NOT IT NEUTRAL");}} 
 
   if (digitalRead(9)==0)
    {n++; if (n > 5000) {n = 0; neutral = 0;Serial.println("IN NEUTRAL");}} 
*/

//Serial.println(gear);

//GearMachine
switch (gear){ 
case 0://Neutral 
    if (digitalRead(up) == LOW) { gear = 11;  X.move(-HalfShift); shiftdirection =4;  OldTime = millis();}
        
     break;
case 1://First
    if (digitalRead(up) == LOW) { gear = 12;  X.move(FullShift); shiftdirection =1;  OldTime = millis();
      break;
    }
    else if (digitalRead(down) == LOW) { gear = 10;  X.move(HalfShift); shiftdirection =3;  OldTime = millis();}
    
    if (digitalRead(12) == LOW) {
      X.move(HalfShift);
      if(NShiftCheck()){
        gear = 0; EEPROM.write(1, 0);
        }
      else {X.move(-HalfShift);}
      } 
      
     break;

     
case 2://Second
    if (digitalRead(up) == LOW) { gear = 13;  X.move(FullShift); shiftdirection =1;  OldTime = millis();
      break;
    }
    else if (digitalRead(down) == LOW) {gear = 11;  X.move(-FullShift); shiftdirection =2;  OldTime = millis();}
   

     if (digitalRead(12) == LOW) {
      X.move(-HalfShift);
      if(NShiftCheck()){
        gear = 0; EEPROM.write(1, 0);
        }
      else {X.move(HalfShift); delay(200);}
      } 
     break;

     
case 3://Third
    if (digitalRead(up) == LOW) { gear = 14;  X.move(FullShift); shiftdirection =1;  OldTime = millis();
      break;
    }
    else if (digitalRead(down) == LOW) {  gear = 12;  X.move(-FullShift); shiftdirection =2;  OldTime = millis();}
    
   
      if (digitalRead(12) == LOW) {
      X.move(-HalfShift - FullShift);
      if(NShiftCheck()){
        gear = 0; EEPROM.write(1, 0);
        }
      else {X.move(+HalfShift + FullShift);delay(200);}
      }     break;

     
case 4://Fourth
    if (digitalRead(up) == LOW) {  gear = 15;  X.move(FullShift); shiftdirection =1;  OldTime = millis(); 
       break;
    }
    else if (digitalRead(down) == LOW) { gear = 13;  X.move(-FullShift); shiftdirection =2;  OldTime = millis();}
    
  if (digitalRead(12) == LOW) {
      X.move(-HalfShift - 2*FullShift);
      if(NShiftCheck()){
        gear = 0; EEPROM.write(1, 0);
        }
      else {X.move(+HalfShift + 2* FullShift);delay(200);}
      }     break;

     
case 5://Fith
    if (digitalRead(up) == LOW) {  gear = 16;  X.move(FullShift); shiftdirection =1;  OldTime = millis();
      break;
    }
    else if (digitalRead(down) == LOW) {  gear = 14;  X.move(-FullShift); shiftdirection =2;  OldTime = millis();}
    
 if (digitalRead(12) == LOW) {
      X.move(-HalfShift - 3*FullShift);
      if(NShiftCheck()){
        gear = 0; EEPROM.write(1, 0);
        }
      else {X.move(+HalfShift + 3*FullShift);delay(200);}
      }        break;

     
case 6://sixth
    if (digitalRead(down) == LOW) {  gear = 15;  X.move(-FullShift); shiftdirection =2;  OldTime = millis();}
    
 if (digitalRead(12) == LOW) {
      X.move(-HalfShift - 4*FullShift);
      if(NShiftCheck()){
        gear = 0; EEPROM.write(1, 0);
        }
      else {X.move(+HalfShift + 4*FullShift);delay(200);}
      }       break;

//Transition States - Saves gear change to memory - ShiftCheck() checks for a full shift, if failed reverts to last gear.
  case 10:
    ShiftCheck(); if (shiftdirection == 0){break;} //If a failed shift happened, break before saving new gear to memmory (this may never be called but it feels safe, FSM scare me)
    gear = 0; EEPROM.write(1, 0);
    break;
  case 11:
    ShiftCheck(); if (shiftdirection == 0){break;}
    gear = 1; EEPROM.write(1, 1);
    break;
  case 12:
    ShiftCheck(); if (shiftdirection == 0){break;}    
    gear = 2; EEPROM.write(1, 2);
    break;
  case 13:
    ShiftCheck(); if (shiftdirection == 0){break;}    
    gear = 3; EEPROM.write(1, 3);
    break;
  case 14:
    ShiftCheck(); if (shiftdirection == 0){break;}    
    gear = 4; EEPROM.write(1, 4);
    break;
  case 15:
    ShiftCheck(); if (shiftdirection == 0){break;}    
    gear = 5; EEPROM.write(1, 5);
    break;
  case 16:
    ShiftCheck(); if (shiftdirection == 0){break;}    
    gear = 6; EEPROM.write(1, 6);
    break;
}//endofgearmachine


//EMERGENCY HOME MODE

while(digitalRead(13)==LOW){
OldTime = millis();
X.setMaxVel(200); 

X.move(3600);
while ((millis()-OldTime)<=21000){
  if (X.readHLFB()){OldTime = OldTime+30000;Serial.println("JAM FOUND");}
  if (digitalRead(11)==LOW){
        X.disable();
        Serial.println("NEUTRAL FOUND");
        delay(5000);
        gear = 0; EEPROM.write(1, 0); X.setMaxVel(95000); 
 }}
 OldTime = millis();
 
 X.disable();
 delay(100);
 X.enable();
 delay(100);

X.move(-3600);
while ((millis()-OldTime)<=21000){
  if (X.readHLFB()){OldTime = OldTime+30000;Serial.println("JAM FOUND");}
  if (digitalRead(11)==LOW){
        X.disable();
        Serial.println("NEUTRAL FOUND");
        delay(5000);  
        gear = 0; EEPROM.write(1, 0); X.setMaxVel(95000); 
 }}
 X.disable();
 delay(100);
 X.enable();
 delay(100);
 X.setMaxVel(95000); 
}





      }//endofloop
